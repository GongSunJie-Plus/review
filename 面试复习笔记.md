# **前端面试复习笔记**

## CSS部分：https://segmentfault.com/a/1190000013325778

### **标椎盒子模型**

​	margin+border+padding+width（content）

### **怪异盒模型**

​	margin+width（border+padding+content）

### **flex布局**

​	阮一峰https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

### **grid布局**

​	阮一峰http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html

### **BFC是什么，有什么用**

https://blog.csdn.net/sinat_36422236/article/details/88763187

BFC块级格式上下文

创建条件：

- 根元素()
- 浮动元素（元素的 float 不是 none）
- 绝对定位元素（元素的 position 为 absolute 或 fixed）
- 行内块元素（元素的 display 为 inline-block）
- 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）
- 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）
- overflow 值不为 visible 的块元素 -弹性元素（display为 flex 或 inline-flex元素的直接子元素）
- 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 等等。

作用：

（1）BFC垂直方向边距重叠

（2）BFC的区域不会与浮动元素的box重叠

（3）BFC是一个独立的容器，外面的元素不会影响里面的元素

（4）计算BFC高度的时候浮动元素也会参与计算

### **引入css的方式**

<link type="text/css" rel="styleSheet" href="path" />

<style> @import url('path'); </style>

​	区别：link属于html标签，优先加载css文件到页面；@import属于css2.1，先加载html再加载css文件。

### **css优先级**

​	1.最近的父类样式高于其他祖先样式

​	2.直接样式（行内样式）高于父类样式

​	3.优先关系：`优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器`

​	!important声明的样式最高，如果优先级相同选择最后出现的（就近原则），继承得到的样式最低

​	4.计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照"就近原则"来判断。

```css
#con-id span {
    color: red;
}
div .con-span {
    color: blue;
}
```

### **双飞翼布局**

### **品字布局**

### **CSS创建三角形、菱形**

​	设置border-top，border-left，border-right，border-bottom大小，结合transparent属性，并设置width和height为0。

```css
.rangle {
    width: 0;
    height: 0;
    border-top: 50px solid red;
    border-bottom: 50px solid blue;
    border-left: 50px solid gray;
    border-right: 50px solid yellow;
}
```

![image-20210505201207169](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210505201207169.png)

## **HTML部分**

### **H5语义化的意义**

- 易修改、易维护。
- 无障碍阅读支持。
- 搜索引擎友好，利于 SEO。
- 面向未来的 HTML，浏览器在未来可能提供更丰富的支持。

### **meta标签**

### **defer和async引入script脚本的区别**

​	async：表示应该立即开始下载脚本，但不能阻止其它页面动作，只对外部脚本有效。

​	defer：表示在文档解析和显示完成后再执行脚本是没问题的，只对外部脚本有效。

![2151798436-59da4801c6772_fix732](D:\新建文件夹 (2)\2151798436-59da4801c6772_fix732.png)

## JS部分

### **数据类型**

​	undefined， Boolean， Number， String ，BigInt， Symbol， null， Function， Object

### **判断各种类型**

​	typeof ：只能判断基本类型，对于结构类型和null不能进一步判断（typeof null === "object"，历史遗留问题对象底层二进制低三位000，null为全零）。

​	instanceof：判断结构类型，用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。               object instanceof contructor。（object.\_\_proto_\_.... === contructor.prototype）

​	判断Array可以使用Array.isArray()，Array.prototype.isPrototypeOf(obj)判断Array是否在obj的原型链上。

​	Object.prototype.toString.call(obj) == '[object Array]'，可以判断各种类型。

​	obj.constructor === Array，实例对象的构造函数

### **遍历相关**

### **闭包是什么，有什么用**	

​	闭包是有权访问另一个函数作用域中变量的函数。作用：setTimeout()，防抖与节流，封装私有变量。

​	使用时注意内存泄漏，手动令作用域变量为null。

### **函数防抖**

```js
function debounce(fn, delay) {
    let timer = null;
    return function() {
        let that = this;
        let args = arguments;
        clearTimeout(timer);
        timer = setTimeout(() => {
            // 精简写法fn.apply(this, arguments);不知道会有什么问题
            fn.apply(that, args);
        }, delay);
    }
}
```

```js
// 立即执行版
function debounce(fn, delay) {
    let timer = null;
    return function() {
        let that = this;
        let args = arguments;
        if (!timer) {
            fn.apply(that, args);
        }
        clearTimeout(timer);
        timer = setTimeout(() => {
            timer = null;
        }, delay);
    }
}
```



### **函数节流**

```js
function throttle(fn, delay) {
    let timer = null;
    return function() {
        if (timer) {
            
        } else {
            timer = setTimeout(() => {
                timer = null;
                fn.apply(this, arguments);
            }, delay);
        }
    }
}
```

```js
// 立即执行版
function throttle(fn, delay) {
    let timer = null;
    return function() {
        if (timer) {
            
        } else {
            fn.apply(this, arguments);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    }
}
```

### **防抖与节流的结合版**

​	在防抖处理的同时，在一定的时间内给用户反馈

```js
function throttlePlus(fn, delay) {
    let timer = null;
    let pre = 0;
    return function() {
        let that = this;
        let args = arguments;
        let now = new Date();
        if (now - pre >= delay) {
            pre = now;
            fn.apply(that, args);
        }
        clearTimeout(timer);
        timer = setTimeout(() => {
            timer = null;
            fn.apply(that, args);
        }, delay);
    }
}
```



### **箭头函数**

​	箭头函数没有自己的this，arguments，super或new.target，不能用作构造函数。

### **this指向**

​	https://juejin.cn/post/6844903488304971789

​	指向调用的地方；箭头函数捕获上下文的this作为自己的this；call和apply在传入对象;bind。

### **new的原理与实现**

​	1.新生成对象
​	2.链接到原型
​	3.绑定this
​	4.返回新对象

```js
function create(){
    //定义空对象
    let obj = {};
    //取出参数列表的第一个参数（构造函数）
    let Con = [].shift.call(arguments);
    //手动指正obj的构造函数为Con（链接原型）
    obj.__proto__ = Con.prototype;
    //调用Con，改变this为obj，传入剩余参数arguments
    let result = Con.apply(obj,arguments);
    //考虑到Con函数中有return的原因，需要对result进行判断
    return result instanceof Object ? result : obj
}
```

### **怎么实现继承**

​	ES6有extends

```js
// 寄生组合继承
function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
}
function Child5() {
    // 继承父类的属性
    Parent5.call(this); 
    this.type = 'child5';
  }
// 继承父类的方法
Child5.prototype = Object.create(Parent5.prototype);
// 修改构造函数指向
Child5.prototype.constructor = Child5;
```

### **实现数组扁平化**

​	flat方法(返回一个扁平化的数组，多重的不行)，递归

```js
function solution(arr) {
    let res = [];
    dfs(arr);
    return res;

    function dfs(arr) {
        for (let i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
                dfs(arr[i]);
            } else {
                res.push(arr[i]);
            }
        }
    }
}
```

### **实现instanceof**

```js
function inst(left, right) {
    const baseType = ['number', 'string', 'boolean', 'undefined', 'symbol', 'null']
	if(baseType.includes(typeof left)) return false
    let cur = left.__proto__;
    while (cur !== null) {
        if (cur === right.prototype) {
            return true;
        }
        cur = cur.__proto__;
    }
    return false;
}
```

### **关于异步的认识**

​	以往的异步setTimeout搭配回调函数。

​	Promise（期约）， async和await关键字。

### **promise是什么**

https://es6.ruanyifeng.com/#docs/promise

​	三种状态：pending，fulfilled/resolved，rejected。

​	实例化promise对象的同步代码会立即执行，异步代码进入异步队列。

基本用法

```
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
// 或者 ///////////
promise.then(function(value) {
  // success
}).catch(function(err) {
	// error
});
```

`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。`finally`方法总是会返回原来的值。

```js
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});

// resolve 的值是 undefined
Promise.resolve(2).then(() => {}, () => {})

// resolve 的值是 2
Promise.resolve(2).finally(() => {})

// reject 的值是 undefined
Promise.reject(3).then(() => {}, () => {})

// reject 的值是 3
Promise.reject(3).finally(() => {})
```

`Promise.all()`方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。只有全部resolved才resolved，只要一个rejected就为rejected。

```js
const p = Promise.all([p1, p2, p3]);
// p1 p2 p3 返回值组成的数组
p.then((arr) => {
    // success
}).catch((err) => {
    // error
});
```

`Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是不会因为某个 Promise 变成`rejected`状态而结束。只要一个是fulfilled就为fulfill

`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。

```js
const p = Promise.race([p1, p2, p3]);

//// 如果fetch没在5秒内返回，则reject
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
```

有时需要将现有对象转为 Promise 对象，`Promise.resolve()`方法就起到这个作用。

```js
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

**Promise.resolve()接受的参数分四种情况：**

**（1）参数是一个 Promise 实例**

如果参数是 Promise 实例，那么`Promise.resolve`将不做任何修改、原封不动地返回这个实例。

**（2）参数是一个`thenable`对象**

`thenable`对象指的是具有`then`方法的对象，比如下面这个对象。

```javascript
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};
```

`Promise.resolve()`方法会将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法。

```javascript
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function (value) {
  console.log(value);  // 42
});
```

上面代码中，`thenable`对象的`then()`方法执行后，对象`p1`的状态就变为`resolved`，从而立即执行最后那个`then()`方法指定的回调函数，输出42。

**（3）参数不是具有`then()`方法的对象，或根本就不是对象**

如果参数是一个原始值，或者是一个不具有`then()`方法的对象，则`Promise.resolve()`方法返回一个新的 Promise 对象，状态为`resolved`。

```javascript
const p = Promise.resolve('Hello');

p.then(function (s) {
  console.log(s)
});
// Hello
```

上面代码生成一个新的 Promise 对象的实例`p`。由于字符串`Hello`不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是`resolved`，所以回调函数会立即执行。`Promise.resolve()`方法的参数，会同时传给回调函数。

**（4）不带有任何参数**

`Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 Promise 对象。

所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用`Promise.resolve()`方法。

```javascript
const p = Promise.resolve();

p.then(function () {
  // ...
});
```

上面代码的变量`p`就是一个 Promise 对象。

需要注意的是，立即`resolve()`的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。

```javascript
setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
```

上面代码中，`setTimeout(fn, 0)`在下一轮“事件循环”开始时执行，`Promise.resolve()`在本轮“事件循环”结束时执行，`console.log('one')`则是立即执行，因此最先输出。

**搭配async和await关键字**

```js
function sleep(ms) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,ms);
    })
}
async function handle(){
    console.log("AAA")
    await sleep(5000)
    console.log("BBB")
}

handle();

// AAA
// BBB (5000ms后)
```



### **手写promise**

```js
class Promise {
    callbacks = [];
    state = 'pending';//增加状态
    value = null;//保存结果
    constructor(fn) {
        fn(this._resolve.bind(this));
    }
    then(onFulfilled) {
        if (this.state === 'pending') {//在resolve之前，跟之前逻辑一样，添加到callbacks中
            // this.callbacks.push(onFulfilled);
        } else {//在resolve之后，直接执行回调，返回结果了
            onFulfilled(this.value);
        }
        return this;
    }
    _resolve(value) {
        this.state = 'fulfilled';//改变状态
        this.value = value;//保存结果
        // this.callbacks.forEach(fn => fn(value));
    }
}
```



## 跨域

### **同源策略**

​	如果两个 URL 的 [protocol](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[port (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port) (如果有指定的话)和 [host](https://developer.mozilla.org/zh-CN/docs/Glossary/Host) 都相同的话，则这两个 URL 是同源。

​	host为域名。

### **CORS和JSONP的区别及优缺点**

​	CORS能解决大多数跨域问题

​	JSONP只支持get请求，兼容性好

## Vue部分

### **vue基础部分**

#### **生命周期**

#### **对路由的了解**

#### **路由hash和history区别**

#### **v-if和v-show的区别**

#### **组件通信**

#### **watch和computed的区别**

#### **关于vuex**

### **vue源码部分https://juejin.cn/post/6844904084374290446**

#### **vue2和vue3双向绑定原理**

**虚拟DOM算法**

#### **diff算法**



## **项目与亮点部分**

### **响应式设计**

### **rem和em的区别**

### **视口**

### **meta标签设置**

### **微前端**

### **前端鉴权**

### **性能优化**

​	https://zhuanlan.zhihu.com/p/121056616

​	**使用CDN**：内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。

​		原理：

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。

2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。

3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。

4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。

5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。

6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。

7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

   ![](D:\新建文件夹 (2)\v2-6fda408c9a38f178e45a1477a00156e6_r.jpg)

## **Webpack部分**

### **打包原理**

### **代码分割**



## **前端安全**

### **xss相关**

### **csrf相关**

### **密码学相关**

### **window.parent和window.opener**

## **Git部分**

## 计算机网络部分

### **tcp和udp的区别及优缺点**



### **DNS的具体过程**

### **输入url后发生了什么**

​	（1）DNS解析：查看浏览器DNS缓存，查看操作系统DNS缓存（host文件），对本地DNS服务器请求，本地服务器查询不到对根域名服务器、顶级域名服务器进行迭代请求

​	（2）获取ip后建立TCP连接，三次握手，第一次SYN，第二次SYN+ACK，第三次ACK

​	（3）如果为https则进行SSL握手。

​	第一阶段建立安全能力 协议版本 会话id 密码构件 压缩方法 初始随机数。

​	第二阶段服务器发送证书 初始随机数  密钥交换 证书请求 技术会话ID 客户端发送结束信号

​	第三阶段服务器接收到密钥 DH计算会话ID 服务端结束信号

​	SSL协议两个重要概念，SSL会话，SSL连接；SSL连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。

​	（3）发送HTTP请求，检查缓存（强缓存+协商缓存）

​	（4）关闭TCP连接，四次挥手。（http1.1默认长连接）

​	（5）浏览器渲染：构件DOM树，样式计算，页面布局，生成分层树，栅格化（将图块转换为位图），显示。

### **http和https的区别**

​	多了个安全套接层，提供安全传输能力，交互速度变慢

### **ssl握手**

### **http状态码**

### **http1.1和http2.0**

## 浏览器部分

### **浏览器存储**

​	cookie，localstorage，sessionstorage

### **浏览器缓存（强缓存+协商缓存）**



### **应用程序缓存**

​	启用应用程序缓存，请在文档的 <html> 标签中包含 manifest 属性

```html
<!DOCTYPE HTML>
<html manifest="demo.appcache">
...
</html>
```



### **reflow和repaint**

### **微任务和宏任务**

https://www.jianshu.com/p/75107522813f

​	宏任务（macrotask ）和微任务（microtask ）

​	宏任务一般是：包括整体代码`script`，`setTimeout`，`setInterval`、`I/O`、`UI render`。
 微任务主要是：`Promise`、`Object.observe`、`MutationObserver`。

![16693808-bb25042137a175ae](D:\新建文件夹 (2)\16693808-bb25042137a175ae.webp)



## **操作系统部分**

https://www.cnblogs.com/everlose/articles/12482212.html

#### **进程和线程的区别**

​	进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。

​	线程上下文切换比进程上下文切换要快得多。

#### **浏览器的tab是进程还是线程**

​	Chrome浏览器属于多进程架构，一个页面一个进程。

#### **浏览器多进程的优势**

​	响应速度：当今网页复杂，多个页面在一个进程影响速度。

​	健壮性：当一个tab崩溃时，会影响其他页面应用。

​	安全性：进程之间不共享资源和地址空间，防止了恶意修改和盗用。

#### **浏览器内核**

​	浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。

​	浏览器内核是多线程的，主要组成：

- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程

#### **前端多进程**

​	可以考虑web worker

