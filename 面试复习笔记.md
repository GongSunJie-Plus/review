# **前端面试复习笔记**

## CSS部分：https://segmentfault.com/a/1190000013325778

### **标椎盒子模型**

​	margin+border+padding+width（content）

### **怪异盒模型**

​	margin+width（border+padding+content）

### **flex布局**

​	阮一峰https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

### **grid布局**

​	阮一峰http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html

### **BFC是什么，有什么用**

https://blog.csdn.net/sinat_36422236/article/details/88763187

BFC块级格式上下文

创建条件：

- 根元素()
- 浮动元素（元素的 float 不是 none）
- 绝对定位元素（元素的 position 为 absolute 或 fixed）
- 行内块元素（元素的 display 为 inline-block）
- 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）
- 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）
- overflow 值不为 visible 的块元素 -弹性元素（display为 flex 或 inline-flex元素的直接子元素）
- 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 等等。

作用：

（1）BFC垂直方向边距重叠

（2）BFC的区域不会与浮动元素的box重叠

（3）BFC是一个独立的容器，外面的元素不会影响里面的元素

（4）计算BFC高度的时候浮动元素也会参与计算

### **引入css的方式**

<link type="text/css" rel="styleSheet" href="path" />

<style> @import url('path'); </style>

​	区别：link属于html标签，优先加载css文件到页面；@import属于css2.1，先加载html再加载css文件。

### **css优先级**

​	1.最近的父类样式高于其他祖先样式

​	2.直接样式（行内样式）高于父类样式

​	3.优先关系：`优先级关系：内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器`

​	!important声明的样式最高，如果优先级相同选择最后出现的（就近原则），继承得到的样式最低

​	4.计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照"就近原则"来判断。

```css
#con-id span {
    color: red;
}
div .con-span {
    color: blue;
}
```

### **双飞翼布局**

### **品字布局**



## **HTML部分**

### **H5语义化的意义**

- 易修改、易维护。
- 无障碍阅读支持。
- 搜索引擎友好，利于 SEO。
- 面向未来的 HTML，浏览器在未来可能提供更丰富的支持。

### **meta标签**

### **defer和async引入script脚本的区别**

## JS部分

### **数据类型**

​	undefined， Boolean， Number， String ，BigInt， Symbol， null， Function， Object

### **判断各种类型**

​	typeof ：只能判断基本类型，对于结构类型和null不能进一步判断（typeof null === "object"，历史遗留问题对象底层二进制低三位000，null为全零）。

​	instanceof：判断结构类型，a instanceof b 即实例对象a的原型是否在b的原型链上（a.\_\_proto\_\_== b.prototype，循环直到null）。

​	判断Array可以使用Array.isArray()，Array.prototype.isPrototypeOf(obj)判断Array是否在obj的原型链上。

​	Object.prototype.toString.call(obj) == '[object Array]'，可以判断各种类型。

​	obj.constructor === Array，实例对象的构造函数

### **遍历相关**

### **闭包是什么，有什么用**	

​	闭包是有权访问另一个函数作用域中变量的函数。作用：setTimeout()，防抖与节流，封装私有变量。

​	使用时注意内存泄漏，手动令作用域变量为null。

### **函数防抖**

```js
function debounce(fn, delay) {
    let timer = null;
    return function() {
        let that = this;
        let args = arguments;
        clearTimeout(timer);
        timer = setTimeout(() => {
            // 精简写法fn.apply(this, arguments);不知道会有什么问题
            fn.apply(that, args);
        }, delay);
    }
}
```

```js
// 立即执行版
function debounce(fn, delay) {
    let timer = null;
    return function() {
        let that = this;
        let args = arguments;
        if (!timer) {
            fn.apply(that, args);
        }
        clearTimeout(timer);
        timer = setTimeout(() => {
            timer = null;
        }, delay);
    }
}
```



### **函数节流**

```js
function throttle(fn, delay) {
    let timer = null;
    return function() {
        if (timer) {
            
        } else {
            timer = setTimeout(() => {
                timer = null;
                fn.apply(this, arguments);
            }, delay);
        }
    }
}
```

```js
// 立即执行版
function throttle(fn, delay) {
    let timer = null;
    return function() {
        if (timer) {
            
        } else {
            fn.apply(this, arguments);
            timer = setTimeout(() => {
                timer = null;
            }, delay);
        }
    }
}
```

### **防抖与节流的结合版**

​	在防抖处理的同时，在一定的时间内给用户反馈

```js
function throttlePlus(fn, delay) {
    let timer = null;
    let pre = 0;
    return function() {
        let that = this;
        let args = arguments;
        let now = new Date();
        if (now - pre >= delay) {
            pre = now;
            fn.apply(that, args);
        }
        clearTimeout(timer);
        timer = setTimeout(() => {
            timer = null;
            fn.apply(that, args);
        }, delay);
    }
}
```



### **箭头函数**

​	箭头函数没有自己的this，arguments，super或new.target，不能用作构造函数。

### **this指向**

​	https://juejin.cn/post/6844903488304971789

​	指向调用的地方；箭头函数捕获上下文的this作为自己的this；call和apply在传入对象;bind。

### **new的原理与实现**

### **怎么实现继承**

​	ES6有extends

```js
// 寄生组合继承
function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
}
function Child5() {
    // 继承父类的属性
    Parent5.call(this); 
    this.type = 'child5';
  }
// 继承父类的方法
Child5.prototype = Object.create(Parent5.prototype);
// 修改构造函数指向
Child5.prototype.constructor = Child5;
```

### **实现数组扁平化**

​	flat方法，递归

### **实现instanceof**

### **关于异步的认识**

### **promise是什么**

### **手写promise**

## 跨域

### **同源策略**



### **CORS和JSONP的区别及优缺点**

​	CORS能解决大多数跨域问题

​	JSONP只支持get请求，兼容性好

## Vue部分

### **vue基础部分**

#### **生命周期**

#### **对路由的了解**

#### **路由hash和history区别**

#### **v-if和v-show的区别**

#### **组件通信**

#### **watch和computed的区别**

### **vue源码部分https://juejin.cn/post/6844904084374290446**

#### **vue2和vue3双向绑定原理**

**虚拟DOM算法**

#### **diff算法**



## **项目与亮点部分**

### **响应式设计**

### **rem和em的区别**

### **视口**

### **meta标签设置**

### **微前端**

### **前端鉴权**

### **性能优化**

​	https://zhuanlan.zhihu.com/p/121056616

​	**使用CDN**：内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。

​		原理：

1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。

2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。

3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。

4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。

5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。

6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。

7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。

   ![](D:\新建文件夹 (2)\v2-6fda408c9a38f178e45a1477a00156e6_r.jpg)

## **Webpack部分**

### **打包原理**

### **代码分割**



## **前端安全**

### **xss相关**

### **csrf相关**

### **密码学相关**

### **window.parent和window.opener**

## **Git部分**

## 计算机网络部分

### **tcp和udp的区别及优缺点**



### **DNS的具体过程**

### **输入url后发生了什么**

​	（1）DNS解析：查看浏览器DNS缓存，查看操作系统DNS缓存（host文件），对本地DNS服务器请求，本地服务器查询不到对根域名服务器、顶级域名服务器进行迭代请求

​	（2）获取ip后建立TCP连接，三次握手，第一次SYN，第二次SYN+ACK，第三次ACK

​	（3）如果为https则进行SSL握手。

​	第一阶段建立安全能力 协议版本 会话id 密码构件 压缩方法 初始随机数。

​	第二阶段服务器发送证书 初始随机数  密钥交换 证书请求 技术会话ID 客户端发送结束信号

​	第三阶段服务器接收到密钥 DH计算会话ID 服务端结束信号

​	SSL协议两个重要概念，SSL会话，SSL连接；SSL连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。

​	（3）发送HTTP请求，检查缓存（强缓存+协商缓存）

​	（4）关闭TCP连接，四次挥手。（http1.1默认长连接）

​	（5）浏览器渲染：构件DOM树，样式计算，页面布局，生成分层树，栅格化（将图块转换为位图），显示。

### **http和https的区别**

​	多了个安全套接层，提供安全传输能力，交互速度变慢

### **ssl握手**

### **http状态码**

### **http1.1和http2.0**

## 浏览器部分

### **浏览器存储**

​	cookie，localstorage，sessionstorage

### **浏览器缓存（强缓存+协商缓存）**

### **reflow和repaint**



## **操作系统部分**

https://www.cnblogs.com/everlose/articles/12482212.html

#### **进程和线程的区别**

​	进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。

​	线程上下文切换比进程上下文切换要快得多。

#### **浏览器的tab是进程还是线程**

​	Chrome浏览器属于多进程架构，一个页面一个进程。

#### **浏览器多进程的优势**

​	响应速度：当今网页复杂，多个页面在一个进程影响速度。

​	健壮性：当一个tab崩溃时，会影响其他页面应用。

​	安全性：进程之间不共享资源和地址空间，防止了恶意修改和盗用。

#### **浏览器内核**

​	浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。

​	浏览器内核是多线程的，主要组成：

- GUI 渲染线程
- JavaScript引擎线程
- 定时触发器线程
- 事件触发线程
- 异步http请求线程